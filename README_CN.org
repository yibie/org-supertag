[[file:README.org][English Version]]

* 简介

org-supertag 是一个增强 org-mode 标签功能的包。它让标签不仅能够为节点设置属性，还能够直接操作节点，还可以根据时间自动执行某些行为，从而提供更灵活的信息管理方式。

org-supertag 为 org-mode 带来更加现代化的笔记体验，比如 #inline-tag 的支持，一个可以自动触发执行某些任务的行为系统……

org-supertag 采用非侵入式设计，与 org-mode 原有的功能和谐共存，同时提供更多可能性。

* org-supertag 的基本使用方法
** 第一步 基本安装

#+begin_src emacs-lisp
(use-package org-supertag
  :straight (:host github :repo "yibie/org-supertag")
  :after org
  :config
  (org-supertag-setup))

(setq org-supertag-sync-directories '("~/Documents/notes/")) ;; 配置同步文件夹
#+end_src

*org-supertag 需要一些 Python 依赖，包括 `torch`,  `epc` 和 `ollama` 等*，以驱动 RAG 和 LLM 服务:

- 使用自动化脚本安装依赖
  
#+begin_src 
cd /path/to/org-supertag/simtag

sh ./setup.sh
#+end_src


** 第二步 简单了解什么是 Node 和 Field
Node 是 org-supertag 对 org-headline 的转化：
- 添加 ID
- 记录到数据库

Node，包括了标题和内容，相当于其它笔记里的笔记块。

本说明中 Node 统称为「笔记」。
** 第二步 输入第一条笔记

使用 org-supertag 记录笔记现在很简单：

1. 和之前一样，你用 * 输入一个 org-headline
2. 输入一个 #，会出现一个自动补全标签的候选栏，
   - C-n/p 上下高亮选择标签，然后按下 RET 添加标签
   - 如果你输入了一个新标签，那么直接按下 RET 就可以添加和创建该标签

🎉恭喜你，此时你已经成功地通过 org-supertag 创建了一条笔记，而且该笔记已经记录到数据库，转化成 Node。

注：在 org-supertag 中，添加标签的时候，会自动将为它所在的 org-headline 添加 ID 并将其记录到数据库中。

简而言之，使用 org-supertag 为一个 org-headline，会自动将它转换为 Node。

** 第三步 打开 Node View，查看 Node 的详细信息

将光标放在 Node 的 org-headline 同一行，然后 ~M-x org-supertag-view-node~ 即可唤出 Node View 界面。

该界面分为几个部分：
- Metadata 区
  - 显示 Node 所添加的标签
  - 可以直接为特定的标签设置 Field 和 Field Value
- Backlink 区
  - 显示引用，和被引用的 Node
  - 分成 Ref from 和 Ref to 两部分
  - 将同时显示引用，和被引用 Node 的具体内容
  - 显示的内容包括 Node 的标题和内容
- 同现关系
  - 显示与标签区里的标签具备同现关系的标签
    
** 第四步 设置 Field 和 Field Value

org-supertag 提供了 2 种设置 Field 和 Field Value 的方式：

- 单独设置
  - 在 Node View 中，将光标移动到 Metadata 区，然后跟着操作提示操作。

- 批量设置
  - ~M-x org-supertag-view-table~ 进入 Table 视图。
  - 和 Node View 同样，可以编辑 Field（增加、删除、修改），也可以设置 Field Value。
  - 单元格之间的跳转操作，和 org-table 一样。

** 第五步 查找你的笔记

org-supertag 提供了 2 种方式来查找笔记： 

~M-x org-supertag-node-find~
- 将在 minibuffer 直接显示一个候选栏
- 在所选择的笔记上按下 RET 则直接跳转到该笔记所在的具体位置

~M-x org-supertag-query~
- 在 minibuffer 输入你要检索的关键词
  - org-supertag 会记录你使用过的关键词，方便你重复使用
  - 支持多个关键词检索，关键词之间需要使用空格隔开
- ~org-supertag-query~ 的检索范围：
  - org-headlines, tags, 以及 field values

*** S-expression 查询引擎
org-supertag 现在支持通过 Org Babel 块进行强大的 S-expression 查询，提供高级过滤和动态表格输出功能。

**** 基本用法
创建一个语言为 `org-supertag-query` 的源代码块：

#+begin_src org-supertag-query :results raw
(tag "project")
#+end_src

**** 查询操作符
- **标签查询**: `(tag "TAG_NAME")` - 查找具有特定标签的节点
- **字段查询**: `(field "FIELD_NAME" "VALUE")` - 查找具有特定字段值的节点
- **逻辑操作符**: 
  - `(and QUERY1 QUERY2)` - 两个条件都必须为真
  - `(or QUERY1 QUERY2)` - 任一条件为真即可
  - `(not QUERY)` - 排除匹配查询的节点
- **基于时间的查询**:
  - `(after "DATE")` - 在指定日期之后创建的节点
  - `(before "DATE")` - 在指定日期之前创建的节点
  - `(between "START_DATE" "END_DATE")` - 在两个日期之间创建的节点
  - 日期格式支持绝对日期 ("2024-01-01") 和相对日期 ("-7d", "+1m", "now")

**** 动态表格输出
查询结果以动态 Org 表格形式显示：
- 第一列：可点击的节点链接（节点标题）
- 第二列：关联的标签
- 附加列：为查询中指定的字段动态添加

**** 交互式查询块插入
使用 `M-x org-supertag-insert-query-block` 在当前位置快速插入预格式化的查询块。

**** 查询示例
#+begin_src org-supertag-query :results raw
;; 查找所有状态为 "On-going" 的项目节点
(and (tag "project") (field "Status" "On-going"))

;; 查找最近 7 天创建的节点
(after "-7d")

;; 查找具有 "project" 标签但状态不是 "Canceled" 的节点
(and (tag "project") (not (field "Status" "Canceled")))
#+end_src

** 第六步 移动你的笔记
~M-x org-supertag-node-move~
- 首先在 minibuffer 里选择目标文件
- 然后选择该笔记的移动位置
- 按下 RET 确认

~org-supertag-node-move~ 可以批量移动多个笔记，只需要高亮多个笔记，然后执行该命令即可。

** 第七步 与知识库对话
~M-x org-supertag-view-chat-open~

- 启动对话界面之后，直接输入关键字，LLM 将根据 RAG 返回的信息进行回复
- 默认对话，相当于一个 RAG 检索结果
  - 展开 Context 里面是 RAG 所返回的结果
- 输入 /commands 看当前有什么命令
  - 直接输入命令，将进入对应的对话模式
- 输入 /define 可以自定义对话模式
  - 语法：~/define <command-name> "prompt"~

* org-supertag 的重要工作机制
** 标签的 Extend 机制
~M-x org-supertag-tag-set-extends~

我们总能碰上很多标签，它们之间存在一些共性，典型例子如形式不同的人际关系：同事、朋友、合作伙伴、供应商等等。他们应当用不同的标签标记，然而，Field 里面的信息则存在很强的共性。

它们可能都需要设置如下属性：

```
- 联系方式
- 公司
- 职位
- 生日
- 备注
```

然而，如果每次都要手动设置这些 Field，那将是一件非常麻烦的事情。所以，在 org-supertag 4.2.0 版本中，我们引入了标签的 Extend 机制。让一个标签，可以从另外一个标签中继承 Field。

举个例子：定义 #person 标签拥有 Name 和 Email 字段。当 #student 标签 Extend #person 时，#student 自动获得 Name 和 Email 字段，同时可以定义自己特有的 StudentID 字段。这样，一个 #student 节点就同时拥有 Name, Email, 和 StudentID。

** 多种视图，多种用法
*** Discovery View 
~M-x org-supertag-view-discover~

- 提供基于标签的发现机制，在浏览知识库的时候，提供探索感
- 可添加多个标签作为过滤条件
- 可动态添加、删除过滤条件

[[./picture/figure13.gif]]

*** Kanaban View
~M-x org-supertag-view-kanban~

- 按照一个标签的 Field 和 Field Value 自动生成一个多列视图，与 Trello 类似
- 笔记以卡片的方式呈现
- 移动卡片：可以直接在卡片上按下 h/l 左右移动卡片，或 RET 修改对应的 Field Value

⚠️暂时还只能按照一个标签中的一个 Field 生成列
⚠️由于是通过字符生成边框，因此如果列太多，超过了当前 Emacs 窗体的宽度，会破坏样式。我不知道如何解决这个问题，如果有人有经验，可以教教我吗？谢谢🙏。

*** Table View
上文已经提到，这里不再赘述。
*** Column View
~M-x org-supertag-view-column~

- 同时比较不同标签组合下的节点，直观分析差异
- 动态添加或删除比较列，满足多样化需求
- 支持向列中添加额外标签，深化比较维度
- 全键盘支持

[[./picture/figure15.gif]]

** 高级查询功能

org-supertag 提供强大的查询功能，超越简单的关键词搜索，支持复杂的数据过滤和分析。

*** S-expression 查询引擎
S-expression 查询引擎允许您使用类似 Lisp 的语法创建复杂查询：

**** 复杂查询示例
#+begin_src org-supertag-query :results raw
;; 查找所有未完成的高优先级项目
(and (tag "project") 
     (field "Priority" "High") 
     (not (field "Status" "Completed")))

;; 查找最近一个月创建的具有特定标签的节点
(and (after "-1m") 
     (or (tag "research") (tag "development")))

;; 查找具有多个字段条件的节点
(and (field "Department" "Engineering")
     (field "Status" "Active")
     (before "2024-12-31"))
#+end_src

**** 增强的交互查询上下文
交互查询界面现在提供更智能的上下文片段：
- 当关键词匹配字段名称或值时，上下文显示 `Field [FIELD_NAME]: FIELD_VALUE`
- 这优先显示相关字段信息而不是一般内容片段
- 使您更容易理解为什么节点匹配您的搜索条件

*** 查询历史和可重用性
- 查询历史自动保存并可重用
- 常用查询在历史中优先显示
- 在同一界面中支持基于关键词和 S-expression 的查询

** 使用 Behavior 系统，形成自动化的工作流

通过将多个操作整合到一个标签中，*实现一键完成复杂操作*，提高工作效率。

[[./picture/figure6.gif]]

~M-x org-supertag-behavior-attach~ 为当前标签添加行为

~M-x org-supertag-behavior-detach~ 为当前标签解除行为

- 标签触发预设动作，实现自动化
行为系统使标签变得"智能"，*在添加/删除标签时自动触发预设的动作*（如改变样式、设置状态等）。

- 行为可定时、组合、带参数
行为可以定时执行、组合使用、带参数，*使 Org-mode 的工作流程更自动化、更高效*。

- 内置行为库与自定义支持
内置行为库，用户既可以使用预定义的常用行为，也可以创建自定义行为。*模块化设计使行为在不同的 Org 文件之间或用户之间轻松共享、重用和扩展*。

*** 行为系统的高级用法

创建自定义行为，编辑 ~/.emacs.d/org-supertag/org-supertag-custom-behavior.el 文件：

以下是一个示例

#+begin_src emacs-lisp
;; 注册一个名为 "@urgent" 的行为
;; 参数说明:
;;   - @urgent: 行为的名称，用于标识和引用这个行为
;;   - :trigger: 触发条件，:on-add 表示添加标签时触发
;;   - :list: 要执行的动作列表，每个动作都是一个命令字符串
;;   - :style: 标签的显示样式，包含字体和前缀图标设置
(org-supertag-behavior-register "@urgent"                 ;; 注册一个名为 "@urgent" 的行为
  :trigger :on-add                                        ;; 添加标签时触发
  :list '("@todo=TODO"                                    ;; 设置 TODO 状态
         "@priority=A"                                    ;; 设置优先级为 A
         "@deadline=today")                               ;; 设置截止日期为今天
  :style '(:face (:foreground "red" :weight bold)         ;; 设置标签显示为红色加粗
          :prefix "🔥"))                                  ;; 在标签前显示火焰图标
#+end_src

更多用法请参考 [[https://github.com/yibie/org-supertag/wiki/Advance-Usage-%E2%80%90-Behavior-System-Guide][Org‐supertag Advance Usage]]

* 深入了解 org-supertag

* FAQ
** 数据库恢复 - 当出现问题时该怎么办？

如果您遇到org-supertag数据库问题（标签丢失、关系丢失或数据损坏），org-supertag提供了一套完整的恢复工具。

*** 快速恢复

#+begin_src emacs-lisp
;; 加载恢复工具
M-x load-file RET org-supertag-recovery.el RET

;; 启动恢复
M-x org-supertag-recovery-full-suite
#+end_src

*** 恢复选项

恢复套件提供9种不同的恢复选项：

1. *诊断数据库状态* - 分析当前数据库状态
2. *从备份恢复* - 自动查找并从最新备份恢复
3. *重建整个数据库* - 从头重新扫描所有org文件
4. *从节点重建标签定义* - 恢复丢失的标签定义
5. *从链接恢复字段定义* - 重建字段结构
6. *从metadata恢复标签关系* - 恢复标签关联
7. *执行完整恢复流程* - 完整的步骤式恢复
8. *查看恢复状态* - 监控恢复进度
9. *退出* - 退出恢复套件

*** 常见恢复场景

**** 场景 1: 标签全部丢失
#+begin_src
症状: org-supertag-tag-add-tag 无法补全标签
解决: 选择选项 4 "从节点重建标签定义"
#+end_src

**** 场景 2: 字段定义丢失
#+begin_src
症状: 标签存在但字段定义为空
解决: 选择选项 5 "从链接恢复字段定义"
#+end_src

**** 场景 3: 标签关系丢失
#+begin_src
症状: 标签存在但没有共现关系
解决: 选择选项 6 "从metadata恢复标签关系"
#+end_src

**** 场景 4: 数据库完全损坏
#+begin_src
症状: 数据库无法加载或为空
解决: 选择选项 2 "从备份恢复" 或选项 3 "重建整个数据库"
#+end_src

*** 恢复功能特点

- **🔍 智能诊断**: 自动分析数据库状态并提供建议
- **📊 进度跟踪**: 详细的恢复状态和进度监控
- **🔄 安全操作**: 恢复前自动备份
- **⚡ 渐进恢复**: 支持单项恢复和完整重建
- **🛡️ 错误处理**: 完善的错误处理和回滚机制

*** 技术细节
恢复工具可以从多个数据源提取数据：
- *节点数据*: `:tags` 属性中的标签引用
- *链接数据*: `:node-field:` 前缀的字段链接
- *元数据*: `tag-cooccur:` 和 `tag-pmi:` 键值对
- *备份文件*: 自动备份文件检测和恢复

更详细的信息请参考附带的 `RECOVERY_GUIDE.md`。

** 为什么要为标签设置「共现关系」？
当一个标签，与另外一个标签，应用到同一个 Node 上，那么它们之间就存在一种关系，叫「共现」。

「共现」关系是所有标签关系中，最为基础的关系。但它有什么用？

1. 当你在「标签发现视图」时，可以通过共现标签，层层过滤
2. 当你管理「标签关系」时，可以通过「共现关系」，快速找到背后存在关系的标签
3. ......

我觉得「共同出现」是世界上最美妙的一种现象。这让我们在添加标签的时候，自动获得有意义的联系。

以下是 org-supertag 当中的「标签共现机制」：

- 在同一个节点当中，同时添加了 A, B 标签，那么这两个标签之间具备「共现关系」
- 父子节点中，父节点和子节点分别添加了 A, B 标签，但在 org-supertag 的角度，这两个标签同样具备「共现关系」

我觉得这是一个巧妙的设计，这样子可以避免对同一个节点树里的节点，重复添加相同的标签。我试过，相当累！

在 org-supertag 中，标签的贡献关系体现在「视图」中。在 README 里我们已经介绍了几种视图，其中 ~org-supertag-view-discover~ 可以将具备「共现关系」的标签作为过滤条件，用于过滤节点。


* Changelog
详细见 [[./CHANGELOG.org][CHANGELOG]]

- 2025-07-29 4.3.0 released
- 2025-07-27 4.2.0 released
- 2025-07-21 4.0.0 released 
- 2025-05-24 3.0.2 released
- 2025-04-05 3.0.0 released
- 2025-01-13 2.0.0 released
- 2024-12-31 1.0.0 released
- 2024-12-20 0.0.2 released
- 2024-12-19 0.0.1 released

* Acknowledgments

org-supertag 深深受到 Tana 的影响，尤其是它将「节点视为标签的操作对象」的核心概念，带来很多启发。

org-supertag 也同时深受 ekg 和 org-node 的影响：
- [[https://github.com/ahyatt/ekg/commits/develop/][ekg]] 是我眼中第一个以标签为中心的笔记工具，我曾经用它记了很多天的日记
- [[https://github.com/meedstrom/org-node][org-node]] 对 org-mode 文件的解析和哈希表的应用，深深影响了 org-supertag 的基础工作机制

* 贡献

欢迎贡献！请查看[[file:.github/CONTRIBUTING.org][贡献指南]]。
