[[file:README.org][English Version]]

* 简介

org-supertag 是一个增强 org-mode 标签功能的包。它让标签不仅能够为节点设置属性，还能够直接操作节点，还可以根据时间自动执行某些行为，从而提供更灵活的信息管理方式。

org-supertag 为 org-mode 带来更加现代化的笔记体验，比如 #inline-tag 的支持，一个可以自动触发执行某些任务的行为系统……

org-supertag 采用非侵入式设计，与 org-mode 原有的功能和谐共存，同时提供更多可能性。

* org-supertag 的基本使用方法
** 第一步 基本安装

#+begin_src emacs-lisp
(use-package org-supertag
  :straight (:host github :repo "yibie/org-supertag")
  :after org
  :config
  (org-supertag-setup))

(setq org-supertag-sync-directories '("~/Documents/notes/")) ;; 配置同步文件夹
#+end_src

*org-supertag 需要一些 Python 依赖，包括 `torch`,  `epc` 和 `ollama` 等*，以驱动 RAG 和 LLM 服务:

- 使用自动化脚本安装依赖
  
#+begin_src 
cd /path/to/org-supertag/simtag

sh ./setup.sh
#+end_src


** 第二步 简单了解什么是 Node
由于太多人对这两个术语感到陌生，所以我将这个简要的解释，先放在开头。我希望你在尝试 org-supertag 之前，务必简单地浏览这一小节。

Node 代表着被 org-supertag 转化之后的 org-headline，表明已经被 org-supertag 记录到数据库，可以被它操作。Node 相当于一般笔记软件里的笔记块，它包括：一个带着 ID 的 org-headline + org-headline 以下所包含的内容。

当 org-supertag 操作 Node 的时候，实际上是对整个笔记块进行操作，举个例子：M-x org-supertag-node-delete，将直接删除整个 Node，清理数据库里记录的 ID、Node 与 Node 之间的引用关系，与 Tag 的 Link 关系等等，清理相关的 Field Value。

这种概念上的区分，是为了让用户清晰的知道笔记状态，是否已经记录到数据库。

为了方便表达，在本使用说明里，Node 都简称为笔记，希望大家在阅读的时候，知道是在说一个笔记块。

** 第二步 输入第一条笔记

使用 org-supertag 记录笔记现在很简单：

1. 和之前一样，你用 * 输入一个 org-headline
2. 输入一个 #，会出现一个自动补全标签的候选栏，
   - C-n/p 上下高亮选择标签，然后按下 RET 添加标签
   - 如果你输入了一个新标签，那么直接按下 RET 就可以添加和创建该标签

🎉恭喜你，此时你已经成功地通过 org-supertag 创建了一条笔记，而且该笔记已经记录到数据库，转化成 Node。

注：在 org-supertag 中，添加标签的时候，会自动将为它所在的 org-headline 添加 ID 并将其记录到数据库中。

简而言之，使用 org-supertag 为一个 org-headline，会自动将它转换为 Node。

** 第三步 打开 Node View，查看 Node 的详细信息

将光标放在 Node 的 org-headline 同一行，然后 ~M-x org-supertag-view-node~ 即可唤出 Node View 界面。

该界面分为几个部分：
- Metadata 区
  - 显示 Node 所添加的标签
  - 可以直接为特定的标签设置 Field 和 Field Value
- Backlink 区
  - 显示引用，和被引用的 Node
  - 分成 Ref from 和 Ref to 两部分
  - 将同时显示引用，和被引用 Node 的具体内容
  - 显示的内容包括 Node 的标题和内容
- 同现关系
  - 显示与标签区里的标签具备同现关系的标签
    
** 第四步 设置 Field 和 Field Value

org-supertag 提供了 2 种设置 Field 和 Field Value 的方式：

- 单独设置
在 Node View 中，将光标移动到 Metadata 区，然后跟着操作提示操作：

[RET] Edit Value [E] Edit Field Definition [a] Add Field [d] Delete Field

- 批量设置
~M-x org-supertag-view-table~ 进入 Table 视图。

** 第五步 查找你的笔记

org-supertag 提供了 2 种方式来查找笔记：

~M-x org-supertag-node-find~
- 将在 minibuffer 直接显示一个候选栏
- 在所选择的笔记上按下 RET 则直接跳转到该笔记所在的具体位置

~M-x org-supertag-query~
- 在 minibuffer 输入你要检索的关键词
  - org-supertag 会记录你使用过的关键词，方便你重复使用
  - 支持多个关键词检索，关键词之间需要使用空格隔开
- ~org-supertag-query~ 的检索范围：
  - org-headlines, tags, 以及 field values

** 第六步 移动你的笔记
~M-x org-supertag-node-move~
- 首先在 minibuffer 里选择目标文件
- 然后选择该笔记的移动位置
- 按下 RET 确认

~org-supertag-node-move~ 可以批量移动多个笔记，只需要高亮多个笔记，然后执行该命令即可。

* org-supertag 的高级用法


** 2. 添加行为

** 第八步 启动聊天窗口

* 深入了解 org-supertag
** 行为系统
** 视图系统
** Chat View 的命令系统
** 智能伙伴机制
** 智能
* FAQ
** 数据库恢复 - 当出现问题时该怎么办？

如果您遇到org-supertag数据库问题（标签丢失、关系丢失或数据损坏），org-supertag提供了一套完整的恢复工具。

*** 快速恢复

#+begin_src emacs-lisp
;; 加载恢复工具
M-x load-file RET org-supertag-recovery.el RET

;; 启动恢复
M-x org-supertag-recovery-full-suite
#+end_src

*** 恢复选项

恢复套件提供9种不同的恢复选项：

1. **诊断数据库状态** - 分析当前数据库状态
2. **从备份恢复** - 自动查找并从最新备份恢复
3. **重建整个数据库** - 从头重新扫描所有org文件
4. **从节点重建标签定义** - 恢复丢失的标签定义
5. **从链接恢复字段定义** - 重建字段结构
6. **从metadata恢复标签关系** - 恢复标签关联
7. **执行完整恢复流程** - 完整的步骤式恢复
8. **查看恢复状态** - 监控恢复进度
9. **退出** - 退出恢复套件

*** 常见恢复场景

**** 场景 1: 标签全部丢失
#+begin_src
症状: org-supertag-tag-add-tag 无法补全标签
解决: 选择选项 4 "从节点重建标签定义"
#+end_src

**** 场景 2: 字段定义丢失
#+begin_src
症状: 标签存在但字段定义为空
解决: 选择选项 5 "从链接恢复字段定义"
#+end_src

**** 场景 3: 标签关系丢失
#+begin_src
症状: 标签存在但没有共现关系
解决: 选择选项 6 "从metadata恢复标签关系"
#+end_src

**** 场景 4: 数据库完全损坏
#+begin_src
症状: 数据库无法加载或为空
解决: 选择选项 2 "从备份恢复" 或选项 3 "重建整个数据库"
#+end_src

*** 恢复功能特点

- **🔍 智能诊断**: 自动分析数据库状态并提供建议
- **📊 进度跟踪**: 详细的恢复状态和进度监控
- **🔄 安全操作**: 恢复前自动备份
- **⚡ 渐进恢复**: 支持单项恢复和完整重建
- **🛡️ 错误处理**: 完善的错误处理和回滚机制

*** 技术细节

恢复工具可以从多个数据源提取数据：
- **节点数据**: `:tags` 属性中的标签引用
- **链接数据**: `:node-field:` 前缀的字段链接
- **元数据**: `tag-cooccur:` 和 `tag-pmi:` 键值对
- **备份文件**: 自动备份文件检测和恢复

更详细的信息请参考附带的 `RECOVERY_GUIDE.md`。

** 什么是 Node？什么是 Field？为什么要和 org-headline、org-properties 区分？

** 为什么要为标签设置「共现关系」？
当一个标签，与另外一个标签，应用到同一个 Node 上，那么它们之间就存在一种关系，叫「共现」。

「共现」关系是所有标签关系中，最为基础的关系。但它有什么用？

1. 当你在「标签发现视图」时，可以通过共现标签，层层过滤
2. 当你管理「标签关系」时，可以通过「共现关系」，快速找到背后存在关系的标签
3. ......

我觉得「共同出现」是世界上最美妙的一种现象。这让我们在添加标签的时候，自动获得有意义的联系。

** 在 org-supertag 中标签的「共现关系」是如何体现的？
以下是 org-supertag 当中的「标签共现机制」：

- 在同一个节点当中，同时添加了 A, B 标签，那么这两个标签之间具备「共现关系」
- 父子节点中，父节点和子节点分别添加了 A, B 标签，但在 org-supertag 的角度，这两个标签同样具备「共现关系」

我觉得这是一个巧妙的设计，这样子可以避免对同一个节点树里的节点，重复添加相同的标签。我试过，相当累！

在 org-supertag 中，标签的贡献关系体现在「视图」中。在 README 里我们已经介绍了几种视图，其中 ~org-supertag-view-discover~ 可以将具备「共现关系」的标签作为过滤条件，用于过滤节点。


* Changelog
详细见 [[./CHANGELOG.org][CHANGELOG]]

- 2025-07-21 4.0.0 released
- 2025-05-24 3.0.2 released
- 2025-04-05 3.0.0 released
- 2025-01-13 2.0.0 released
- 2024-12-31 1.0.0 released
- 2024-12-20 0.0.2 released
- 2024-12-19 0.0.1 released

* 未来计划

- ✅能够提供更多查询的范围，比如针对一个文件或多个文件的查询
- ✅初步实现一个命令系统，让标签自动触发命令，比如节点添加了名为 Task 的标签时，它会自动设置为 TODO，并自动设置优先级为 A，以及自动将节点的背景色改为黄色
- ✅实现一个任务调度系统，让多个节点组合起来，完成一系列的任务，比如自动设置晚上 9 点进行每日回顾，并自动将回顾结果插入到回顾节点中（实验性功能，未必会实现）
- ✅与 AI 结合，不同的标签关联不同的 Prompt，比如当节点被标记为 "任务" 时，自动触发 AI 命令，令该节点自动生成一个任务列表
- ✅像 Tana 那样，提供更多视图（实验性功能，未必会实现）

* Acknowledgments

org-supertag 深深受到 Tana 的影响，尤其是它将「节点视为标签的操作对象」的核心概念，带来很多启发。

org-supertag 也同时深受 ekg 和 org-node 的影响：
- [[https://github.com/ahyatt/ekg/commits/develop/][ekg]] 是我眼中第一个以标签为中心的笔记工具，我曾经用它记了很多天的日记
- [[https://github.com/meedstrom/org-node][org-node]] 对 org-mode 文件的解析和哈希表的应用，深深影响了 org-supertag 的基础工作机制

* 贡献

欢迎贡献！请查看[[file:.github/CONTRIBUTING.org][贡献指南]]。
